#include "hal_i2c_driver.h"
#include <stdint.h>


/////********************************************************* HELPER FUNCTIONS ******************************************************************/////

static void hal_i2c_enable_peripheral(I2C_TypeDef *i2cx)
{
	
i2cx ->CR1 |= I2C_REG_CR1_ENABLE_I2C;
	
}


static void hal_i2c_disable_peripheral(I2C_TypeDef *i2cx)
{
	
i2cx ->CR1 &= ~(I2C_REG_CR1_ENABLE_I2C);
	
}


static void hal_i2c_manage_clock_stretch(I2C_TypeDef *i2cx, uint32_t no_stretch)
{
	if(no_stretch)
	{
		i2cx ->CR1 |= I2C_REG_CR1_NOSTRETCH;
	}
	else
	{
		i2cx ->CR1 &= ~(I2C_REG_CR1_NOSTRETCH);
	}

}


static void hal_i2c_set_own_address1(I2C_TypeDef *i2cx , uint32_t own_address)
{
	
	i2cx -> OAR1 &= ~(0x7f << 1);                          // Bit 1-7 are used to configure the 7 bit I2C Device Address, therefore clearing them initiallt //
	i2cx -> OAR1 |= (own_address << 1);                    // set the address from location 1 //
	
}


static void hal_i2c_set_addressing_mode(I2C_TypeDef *i2cx,uint32_t adr_mode)
{
	if(adr_mode == I2C_ADDRMODE_10BIT)
     i2cx ->OAR1 |= I2C_REG_OAR1_ADDRMODE;
	else
		 i2cx ->OAR1 &= ~(I2C_REG_OAR1_ADDRMODE);
}


static void hal_i2c_set_fm_mode_duty_cycle(I2C_TypeDef *i2cx, uint32_t duty_cycle)
{
	if(duty_cycle == I2C_FM_DUTY_16BY9)
	  {
			i2cx->CCR |= I2C_REG_CCR_DUTY;                     
	  }
	else
    {
			i2cx->CCR &= ~(I2C_REG_CCR_DUTY);                  //Default    
		}
}


static void hal_i2c_clk_init(I2C_TypeDef *i2cx,uint32_t clkspeed, uint32_t duty_cycle)
{
	uint32_t pclk = I2C_PERIPHERAL_CLK_FREQ_10MHZ;
	i2cx->CR2 &= ~(0x3F);
	i2cx->CR2 |= (pclk & 0x3F);
 	hal_i2c_configure_ccr(i2cx,pclk,clkspeed,duty_cycle);  // Configure the I2C serial clock //
	hal_i2c_rise_time_configuration(i2cx,pclk,clkspeed);   // Setting up the rise time of the serial clock //
}


static void hal_i2c_generate_start_condition(I2C_TypeDef *i2cx)
{
	
	i2cx ->CR1 |= I2C_REG_CR1_START_GEN; 
	
}


static void hal_i2c_generate_stop_condition(I2C_TypeDef *i2cx)
{
	
	i2cx ->CR1 |= I2C_REG_CR1_STOP_GEN; 
	
}


static void hal_i2c_configure_buffer_interrupt(I2C_TypeDef *i2cx,uint32_t enable)   // Buffer Interrupts : TXE and RXNE //
{
	if(enable)
		i2cx ->CR2 |= I2C_REG_CR2_BUF_INT_ENABLE;
  else
		i2cx ->CR2 &= ~(I2C_REG_CR2_BUF_INT_ENABLE);
}


static void hal_i2c_configure_error_interrupt(I2C_TypeDef *i2cx,uint32_t enable)
{
	if(enable)
		i2cx ->CR2 |= I2C_REG_CR2_ERR_INT_ENABLE;
  else
		i2cx ->CR2 &= ~(I2C_REG_CR2_ERR_INT_ENABLE);
}


static void hal_i2c_configure_evt_interrupt(I2C_TypeDef *i2cx,uint32_t enable)
{
	if(enable)
		i2cx ->CR2 |= I2C_REG_CR2_EVT_INT_ENABLE;
  else
		i2cx ->CR2 &= ~(I2C_REG_CR2_EVT_INT_ENABLE);
}


static uint8_t is_bus_busy(I2C_TypeDef * i2cx)
{
	if(i2cx->SR2 & I2C_REG_SR2_BUS_BUSY_FLAG)
		return 1;
	else
	  return 0;
}


static void i2c_wait_until_sb_set(I2C_TypeDef *i2cx)
{
	
	while(!(i2cx->SR1 & I2C_REG_SR1_SB_FLAG ));            // Wait until Start Byte is generated by the master //   
	
}


static void i2c_wait_until_addr_set(I2C_TypeDef * i2cx)
{
	
	while(!(i2cx->SR1 & I2C_REG_SR1_ADDR_SENT_FLAG ));     // Wait until master has successfully sent the address i.e ACK is received //
	
}


static void hal_i2c_clear_addr_flag(i2c_handle_t *hi2c)
{
	
	uint32_t tmpreg;
	tmpreg = hi2c->Instance->SR1;                          // Clear ADDR flag by just reding these SR1 and SR2 registers //    
	tmpreg = hi2c->Instance->SR2;

}


static void hal_i2c_slave_handle_stop_condition(i2c_handle_t*hi2c)
{
	
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_EVT_INT_ENABLE;
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_BUF_INT_ENABLE;
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_ERR_INT_ENABLE;
	
	hal_i2c_clear_stop_flag(hi2c);
	
	hi2c->Instance->CR1 &= ~I2C_CR1_ACK;
	
	hi2c->State = HAL_I2C_STATE_READY;

}


static void hal_i2c_slave_handle_TXE_interrupt(i2c_handle_t *hi2c)
{
	if(hi2c->XferCount !=0)
	{
		
		hi2c->Instance->DR = (*hi2c->pBuffPtr++);
		hi2c->XferCount--;
	}
}



static void hal_i2c_slave_tx_handle_btf(i2c_handle_t *hi2c)
{
	if(hi2c->XferCount !=0)
	{
		hi2c->Instance->DR = *hi2c->pBuffPtr++;
		hi2c->XferCount--;
	}
}



static void hal_i2c_slave_handle_RXNE_interrupt(i2c_handle_t *hi2c)
{
	if(hi2c->XferCount !=0)
	{
		
		(*hi2c->pBuffPtr++) = hi2c->Instance->DR;
		hi2c->XferCount--;
	}
}


static void hal_i2c_slave_rx_handle_btf(i2c_handle_t *hi2c)
{
	if(hi2c->XferCount !=0)
	{
		
	 *hi2c->pBuffPtr++ = hi2c->Instance->DR;
		hi2c->XferCount--;
		
	}
}



void hal_i2c_error_cb(i2c_handle_t *I2cHandle)
{
	while(1);
}



static void hal_i2c_slave_handle_ack_failure(i2c_handle_t *hi2c)
{
	
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_EVT_INT_ENABLE;
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_BUF_INT_ENABLE;
	hi2c->Instance->CR2 &= ~I2C_REG_CR2_ERR_INT_ENABLE;
	
	hi2c->Instance->SR1 &= ~ (I2C_REG_SR1_AF_FAILURE_FLAG);
	
	hi2c->Instance->CR1 &= ~I2C_REG_CR1_ACK;
	
	hi2c->State = HAL_I2C_STATE_READY;

}







/////********************************************************* API DEFINITIONS ****************************************************************/////


//*********************************************************** MASTER TX ***********************************************************************//


void hal_i2c_master_tx(i2c_handle_t *handle ,uint8_t slave_address, uint8_t *buffer, uint32_t len )
{
	
	handle->pBuffPtr  = buffer;
	handle->XferCount = len;
	handle->XferSize  = len;
	
	handle->State     = HAL_I2C_STATE_BUSY_TX;
	
	hal_i2c_enable_peripheral(handle->Instance);
	
	hal_i2c_generate_start_condition(handle ->Instance);
	
	i2c_wait_until_sb_set(handle->Instance);
	
	hal_i2c_send_addr_first_(handle->Instance, slave_address);
	
	i2c_wait_until_addr_set(handle->Instance);
	
	hal_i2c_clear_addr_flag(handle -> Instance);
	
	hal_i2c_configure_buffer_interrupt(handle->Instance,1);
	hal_i2c_configure_error_interrupt(handle->Instance,1);
	hal_i2c_configure_evt_interrupt(handle->Instance,1);
	
}

//************************************************************ MASTER RX ***********************************************************************//

void hal_i2c_master_rx(i2c_handle_t * handle, uint8_t slave_addr, uint8_t *buffer, uint32_t len)
{
	handle->pBuffPtr   =buffer;
	handle->XferCount  = len;
	handle->XferSize   = len;
	
	handle->State = HAL_I2C_STATE_BUSY_RX;
	
	hal_i2c_enable_peripheral(handle->Instance);
	
	handle->Instance->CR1 &= ~( I2C_CR1_POS );             // Make sure the the POS bit is disabled //              
	
	handle->Instance->CR1 |= I2C_CR1_ACK;                  // Make sure that ACKing is enabled //
   
	hal_i2c_generate_start_condition(handle->Instance);
	
	i2c_wait_until_sb_set(handle->Instance);
	
	hal_i2c_send_addr_first_(handle->Instance, slave_addr);
	
	i2c_wait_until_addr_set(handle->Instance);
	
	hal_i2c_clear_addr_flag(handle->Instance);
	
	hal_i2c_configure_buffer_interrupt(handle->Instance,1);
	hal_i2c_configure_error_interrupt(handle->Instance,1);
	hal_i2c_configure_evt_interrupt(handle->Instance,1);
	
}

//*********************************************************** SLAVE TX ************************************************************************//

// It does not have any address phase //

void hal_i2c_slave_tx(i2c_handle_t *handle,uint8_t *buffer, uint32_t len )
{
	
	handle->pBuffPtr  = buffer;
	handle->XferCount = len;
	handle->XferSize  = len;
	
	handle->State     = HAL_I2C_STATE_BUSY_TX;
	
	hal_i2c_enable_peripheral(handle->Instance);
	
	handle->Instance->CR1 &= ~( I2C_CR1_POS );             // Make sure the the POS bit is disabled //              
	
	handle->Instance->CR1 |= I2C_CR1_ACK;                  // Make sure that ACKing is enabled //
	
	
	hal_i2c_configure_buffer_interrupt(handle->Instance,1);
	hal_i2c_configure_error_interrupt(handle->Instance,1);
	hal_i2c_configure_evt_interrupt(handle->Instance,1);
	
}

//********************************************************** SlAVE RX *************************************************************************//

// Similar to SLAVE TX //

void hal_i2c_slave_rx(i2c_handle_t *handle,uint8_t *buffer, uint32_t len )
{
	
	handle->pBuffPtr  = buffer;
	handle->XferCount = len;
	handle->XferSize  = len;
	
	handle->State     = HAL_I2C_STATE_BUSY_RX;
	
	hal_i2c_enable_peripheral(handle->Instance);
	
	handle->Instance->CR1 &= ~( I2C_CR1_POS );             // Make sure the the POS bit is disabled //              
	
	handle->Instance->CR1 |= I2C_CR1_ACK;                  // Make sure that ACKing is enabled //
	
	
	hal_i2c_configure_buffer_interrupt(handle->Instance,1);
	hal_i2c_configure_error_interrupt(handle->Instance,1);
	hal_i2c_configure_evt_interrupt(handle->Instance,1);
	
}




/////************************************************** EVENT INTERRUPT HANDLERS ******************************************************/////






static void hal_i2c_master_handle_TXE_interrupt(i2c_handle_t *hi2c)
{
	hi2c-> Instance->DR = (*hi2c->pBuffPtr++);             // Write data to DR //
	hi2c-> XferCount--;
	
	if(hi2c-> XferCount-- ==0)
	{
		hi2c->Instance->CR2 &= ~I2C_REG_CR2_BUF_INT_ENABLE;  // Disable Buffer Interrupt // 
		
	}

}





// When in TX mode , BTF flag will be set when both DR and Shift register will be empty //  

static void hal_i2c_master_tx_handle_btf(i2c_handle_t *hi2c)
{
	
	if(hi2c->XferCount != 0)                               // If Transmission has not ended //
	{
		hi2c->Instance->DR = (*hi2c->pBuffPtr++);            // Continue Transmission //
		hi2c->XferCount--;
	}
	
	else
  {
		hi2c->Instance->CR2 &= ~I2C_REG_CR2_EVT_INT_ENABLE;
		hi2c->Instance->CR2 &= ~I2C_REG_CR2_BUF_INT_ENABLE;
		hi2c->Instance->CR2 &= ~I2C_REG_CR2_ERR_INT_ENABLE;
		
		hi2c->Instance->CR1 |= I2C_REG_CR1_STOP_GEN;
		
		hi2c->State = HAL_I2C_STATE_READY;
		
	}

}






static void hal_i2c_slave_event_handle(i2c_handle_t *hi2c)
{
	
	uint32_t tmp1 = (hi2c->Instance->SR1 & I2C_REG_SR1_ADDR_FLAG);
	uint32_t tmp2 = (hi2c->Instance->CR2 & I2C_REG_CR2_EVT_INT_ENABLE);
	uint32_t tmp3 = (hi2c->Instance->SR1 & I2C_REG_SR1_STOP_DETECTION_FLAG);
	uint32_t tmp4 = (hi2c->Instance->SR2 & I2C_REG_SR2_TRA_FLAG);
	
	// ADDR condition set in this slave //
	if(tmp1 && tmp2)  
	{
		
		// until you clear out ADDR flag I2C clock will be stretched //
		hal_i2c_clear_addr_flag(hi2c); 
		
	}
	
	// STOP condition generation by master //
	else if(tmp3 && tmp2)
	{
		hal_i2c_slave_handle_stop_condition(hi2c);
		
	}
		
	else if(tmp4)                                      // I2C in transmittor mode //
	{
		
	uint32_t tmp1 = (hi2c->Instance->SR1 & I2C_REG_SR1_TXE_FLAG);
	uint32_t tmp2 = (hi2c->Instance->CR2 & I2C_REG_CR2_BUF_INT_ENABLE);
	uint32_t tmp3 = (hi2c->Instance->SR1 & I2C_REG_SR1_BTF_FLAG);
	uint32_t tmp4 = (hi2c->Instance->CR2 & I2C_REG_CR2_EVT_INT_ENABLE);
	
		if(tmp1 && tmp2 &&!tmp3)
		{
			
			hal_i2c_slave_handle_TXE_interrupt(hi2c);
			
		}
		else if(tmp3 && tmp4)
		{
			hal_i2c_slave_tx_handle_btf(hi2c);
		
		}
		
	}
	
	else                                               // I2C in reciever mode // 
	{
		
	uint32_t tmp1 = (hi2c->Instance->SR1 & I2C_REG_SR1_RXNE_FLAG);
	uint32_t tmp2 = (hi2c->Instance->CR2 & I2C_REG_CR2_BUF_INT_ENABLE);
	uint32_t tmp3 = (hi2c->Instance->SR1 & I2C_REG_SR1_BTF_FLAG);
	uint32_t tmp4 = (hi2c->Instance->CR2 & I2C_REG_CR2_EVT_INT_ENABLE);
	
		if(tmp1 && tmp2 && !tmp3)
		{
			
			hal_i2c_slave_handle_RXNE_interrupt(hi2c);
			
		}
		else if(tmp3 && tmp4)
		{
			hal_i2c_slave_rx_handle_btf(hi2c);
		
		}
	}
	
}


/////*********************************************** ERROR INTERRUPT HANDLER **************************************************************/////


void hal_i2c_handle_error_interrupt(i2c_handle_t *hi2c)
{
	
	
	uint32_t tmp1 = 0, tmp2 = 0, tmp3 = 0 ;
	
	tmp1 = ( hi2c->Instance->SR1 & I2C_REG_SR1_BUS_ERROR_FLAG );
	tmp2 = ( hi2c->Instance->CR2 & I2C_REG_CR2_ERR_INT_ENABLE );
	
	if(tmp1 & tmp2)                                     // Bus error //             
	{
		hi2c->ErrorCode |= HAL_I2C_ERROR_BERR;
		
		hi2c->Instance->SR1 &= ~(I2C_REG_SR1_BUS_ERROR_FLAG);
	
	}
	
	tmp1 = ( hi2c->Instance->SR1 & I2C_REG_SR1_ARLO_FLAG );
	tmp2 = ( hi2c->Instance->CR2 & I2C_REG_CR2_ERR_INT_ENABLE );
	
	if(tmp1 & tmp2)                                     // Arbitation loss error //             
	{
		hi2c->ErrorCode |= HAL_I2C_ERROR_ARLO;
		
		hi2c->Instance->SR1 &= ~(I2C_REG_SR1_ARLO_FLAG);
	
	}
	
	
	tmp1 = ( hi2c->Instance->SR1 & I2C_REG_SR1_AF_FAILURE_FLAG );
	tmp2 = ( hi2c->Instance->CR2 & I2C_REG_CR2_ERR_INT_ENABLE );
	
	if(tmp1 & tmp2)                                     // Acknowledge failure error //             
	{
		tmp1 = (hi2c->Instance->SR2 & I2C_REG_SR2_MSL_FLAG);
		tmp2 = hi2c->XferCount;
		tmp3 = hi2c->State;
		if( !tmp1 && (tmp2==0) && ( tmp3 == HAL_I2C_STATE_BUSY_TX ))
		{
			
			hal_i2c_slave_handle_ack_failure(hi2c);
			
		}
		else
    {
			hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
			
			hi2c->Instance->SR1 &= ~(I2C_REG_SR1_AF_FAILURE_FLAG);
		}
	}
	
	tmp1 = ( hi2c->Instance->SR1 & I2C_REG_SR1_OVR_FLAG );
	tmp2 = ( hi2c->Instance->CR2 & I2C_REG_CR2_ERR_INT_ENABLE );
	
	if(tmp1 & tmp2)                                     // Over/Under run error //             
	{
		hi2c->ErrorCode |= HAL_I2C_ERROR_OVR;
		
		hi2c->Instance->SR1 &= ~(I2C_REG_SR1_OVR_FLAG);
	
	}
	
	if(hi2c->ErrorCode != HAL_I2C_ERROR_NONE)
	{
		hi2c->State = HAL_I2C_STATE_READY;
		
		hi2c->Instance->CR1 &= ~I2C_REG_CR1_POS;
		
		hal_i2c_error_cb(hi2c);
		
	}
	
	
	
}























